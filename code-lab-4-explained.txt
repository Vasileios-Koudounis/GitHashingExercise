example 1:
Δημιουργεί μία child διεργασία με την fork() και την αποθηκεύει στην pid.
Αν pid<0, η fork απέτυχε, τυπώνει error message και τερματίζει.
Αν pid==0, ο κώδικας θα τρέξει την child process. Θα τυπώσει την PID της child και την PID της parent. Με την execlp(), Θα εκτελέσει ένα διαφορετικό process: θα τυπώσει όλα τα περιεχόμενα του directory σε long format (ls -l). Αν αποτύχει η execlp(), τυπώνει error message και τερματίζει.
Αν pid>0, ο κώδικας θα τρέξει την parent process. Θα τυπώσει την PID της parent και την PID της child. Θα περιμένει μέχρι να τελειώσει η child process ώστε να μην τελειώσει η parent πριν από αυτή. Θα τυπώσει μήνυμα 'terminated' και τέλος.
~output: 
PPID, created Child PID
PID, PPID
"όλα τα αρχεία του directory με την ls -l"
PPID child has terminated.


example 2:
Δεν χρησιμοποιεί την fork() για να δημιουργήσει κάποια child process. Γι' αυτό, η getpid() θα επιστρέψει το PID της τρέχουσας διεργασίας. Η getppid() θα επιστρέψει την PID της process που δημιούργησε το την τρέχουσα διεργασία, άρα το τερματικό μας.
~output:
(PID) *same as "ps"
(PPID)


example 3:
Το SIGINT είναι το σήμα που στέλνει το λειτουργικό μας όταν πατηθεί το CTRL + C.
Η sigint_handler() είναι μια custom συνάρτηση που καλείται όταν το πρόγραμμα λάβει το SIGINT.
Εμφανίζει ένα μήνυμα ότι το SIGINT πάρθηκε και τερματίζει το πρόγραμμα. 
Η signal() χρησιμοποιείται για να καταχωρηθεί η συνάρτηση sigint_handler ως handler για το σήμα SIGINT. Αν αποτύχει η καταχώρηση, τυπώνεται μήνυμα λάθους και τερματίζει το πρόγραμμα.
Η sleep(2) σταματάει τη διεργασία για 2 δευτερόλεπτα και μετά συνεχίζει.
~output:
PID
μήνυμα διευκρίνησης Press CTRL+C to trigger SIGINT
while loop που τυπώνει "Running..." κάθε 2 δευτερόλεπτα
Αυτό θα τυπώνεται μέχρι να πατήσουμε CTRL+C.
Όταν το πατήσουμε, το σήμα SIGINT ενεργοποιεί την sigint_handler() η οποία τερματίζει το πρόγραμμα.


example 4:
Η συνάρτηση sigint_handler απλώς εκτυπώνει ένα μήνυμα και δεν κάνει τίποτα άλλο.
Η signal() χρησιμοποιείται για να καταχωρηθεί η συνάρτηση sigint_handler ως handler για το σήμα SIGINT. Αν αποτύχει η καταχώρηση, τυπώνεται μήνυμα λάθους και τερματίζει το πρόγραμμα.
Με την καταχώρηση αυτή, το Ctrl+C δεν θα τερματίζει το πρόγραμμα όπως στο example3.c.
~output
PID
infinate loop: "Press CTRL+C to escape..." κάθε 2 δευτερόλεπτα
Το πρόγραμμα παραμένει σε λειτουργία μέχρι να τερματιστεί με άλλον τρόπο (π.χ., kill -9 PID ή Ctrl+\)


example 5:
Η συνάρτηση sigusr1_handler() χειρίζεται το σήμα SIGUSR1
Το πρόγραμμα δημιουργεί μία διεργασία child, μέσω της fork().
Αν pid=-1, error message & exit
Αν pid=0, βρισκόμαστε στον κώδικα της child.
Η signal() χρησιμοποιείται για να καταχωρηθεί η συνάρτηση sigusr1_handler ως handler για το σήμα SIGUSR1. Αν αποτύχει η καταχώρηση, τυπώνεται μήνυμα λάθους και τερματίζει το πρόγραμμα. Έπειτα τυπώνει το PID της child και απλά περιμένει για το σήμα SIGUSR1 με την pause().
Αν το pid πάρει οποιαδήποτε άλλη τιμή, θα βρεθούμε στον κώδικα της parent.
Τυπώνει το Parent PID και έπειτα το PID της child. Περιμένει 3 δευτερόλεπτα με την sleep(3).
Στέλνει ένα SIGUSR1 σήμα στην child process. Άμα αποτύχει, τερματίζει με μήνυμα. Αλλιώς, η child ξεφεύγει από την pause() που είχε μπει και εκτυπώνει το μήνυμα που είχε ανατεθεί στην sigusr1_handler().
sleep(1) 1 δευτερόλεπτο για να εκτελεστεί η διεργασία child.
Τότε η parent process θα στείλει το σήμα SIGTERM μέσω της kill() στην child, για να τερματίσει η διεργασία.
Η wait(NULL) περιμένει τον τερματισμό της child.
Αφού τερματίσει, τερματίζει και η parent τυπώνοντας ένα μήνυμα
